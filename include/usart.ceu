native/pre do
    ##if _WIN32 || _WIN64
        ##define WIN_OS
    ##endif
end

native/pre do
    ##ifdef WIN_OS
        ##include <windows.h>
        HANDLE hSerial;
    ##else
        // ver o que realmente é necessário
        ##include <errno.h>
        ##include <fcntl.h> 
        ##include <stdio.h>
        ##include <stdlib.h>
        ##include <string.h>
        ##include <termios.h>
        ##include <unistd.h>
    ##endif
end 

{##ifndef WIN_OS}
var int fd=_;
{##endif}
    
code/await USART_Init (var text port, var int? baudRate) -> NEVER do
    if (not baudRate?) then
        baudRate = 9600;
    end

    {##ifdef WIN_OS}
        var int portNumber = {atoi(@port)};
        {
        char portStr[15];

        if (@portNumber > 9){
            sprintf(portStr, "\\\\.\\COM%d", @portNumber);
        }else{
            sprintf(portStr, "COM%d", @portNumber);
        }

        // OPEN
        hSerial = CreateFile(portStr,
                GENERIC_READ | GENERIC_WRITE,
                0,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL);

        //ToDo check when this error occurs
        ceu_assert(hSerial != INVALID_HANDLE_VALUE, "bug found. Check if the Arduino board is connect on the used port and if this port is busy.");

        DCB dcbSerialParams = {0};
        ceu_assert(GetCommState(hSerial,&dcbSerialParams), "bug found in Usart on GetCommState invocation");

        dcbSerialParams.BaudRate    = @baudRate!;
        dcbSerialParams.ByteSize    = 8;
        dcbSerialParams.StopBits    = ONESTOPBIT;
        dcbSerialParams.Parity      = NOPARITY;
        dcbSerialParams.fDtrControl = DTR_CONTROL_ENABLE;
        ceu_assert(SetCommState(hSerial, &dcbSerialParams), "bug found in Usart on SetCommState invocation");

        PurgeComm(hSerial, PURGE_RXCLEAR | PURGE_TXCLEAR);
    ##endif} 

    {##ifndef WIN_OS}
        outer.fd = _open(port, {O_RDWR});
        _ceu_assert(outer.fd != -1, "serial error");
        //ToDo: Set baudRate 
        //set_interface_attribs(fd, B115200);
        var int flags = _fcntl(outer.fd, _F_GETFL, 0);
        var int ok    = _fcntl(outer.fd, _F_SETFL, flags|_O_NONBLOCK);
        _ceu_assert(ok == 0, "serial error");
    {##endif}


    do finalize with
        {
            ##ifdef WIN_OS
                CloseHandle(hSerial);
            ##else
                close(@(outer.fd));
            ##endif
        }
    end


    await FOREVER;
end

code/await USART_Tx (var&[] byte str) -> none do
    {
        const char* strC = @&&str[0] as _char&&;
        int nbChar = strlen(strC);
    }

    {
        ##ifdef WIN_OS    
            DWORD bytesSend;

            ceu_assert(WriteFile(hSerial, (void*)strC, nbChar, &bytesSend, 0), "bug found in Usart_TX on WriteFile invocation");
            ceu_assert(bytesSend == nbChar, "bug found in Usart_TX on bytesSend verification");
        ##else
            int bytesSend = write(@(outer.fd), strC, nbChar);
            ceu_assert(bytesSend == nbChar, "bug found in Usart_TX on bytesSend verification");
            tcdrain(@(outer.fd));
        
        ##endif
    }
end

code/await USART_Rx (var&[] byte str, var int? nbChar) -> none do
    if (not nbChar?) then
        nbChar = $$str as int;
    end
    
    {##ifdef WIN_OS}
        every 10ms do
            {
                DWORD errors;
                COMSTAT status;

                ClearCommError(hSerial, &errors, &status);
                if (status.cbInQue >= @nbChar!)
                    break;
            }
        end

        {
            DWORD bytesRead;

            char* strC = @&&str[0] as _char&&;

            ceu_assert(ReadFile(hSerial, strC, @nbChar!, &bytesRead, NULL), "bug found");
            ceu_assert(bytesRead ==  @nbChar!, "bug found");
        }
    {##else}
        every 10ms do
            {
                char* strC = @&&str[0] as _char&&;
                int n = read (@(outer.fd), strC, @nbChar!);
                if (n >= @nbChar!)
                    break;
            }
        end
    {##endif}
end
